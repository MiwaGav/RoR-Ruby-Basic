arr = [621, 445, 147, 159, 430, 222, 482, 44, 194, 522, 652, 494, 14, 126, 532, 387, 441, 471, 337, 446, 18, 36, 202, 574, 556, 458, 16, 139, 222, 220, 107, 82, 264, 366, 501, 319, 314, 430, 55, 336]
# Узнать количество элементов в массиве
p arr.size
puts ""
# Перевернуть массив
p arr.reverse
puts ""
# Найти наибольшее число
p arr.max
puts ""
# Найти наименьшее число
p arr.min
puts ""
# Отсортировать от меньшего к большему
p arr.sort
puts ""
# Отсортировать от большего к меньшему
p arr.sort.reverse
puts ""
# Удалить все нечетные числа
p arr.reject{ |e| e.odd? }
puts ""
# Оставить только те числа, которые без остатка делятся на 3
p arr.select{ |e| e % 3 == 0 }
puts ""
# Удалить из массива числа, которые повторяются (то есть, нужно вывести массив, в котором нет повторов)
p arr.uniq
puts ""
# Разделить каждый элемент на 10, в результате элементы не должны быть округлены до целого
p arr.map{ |e| e.to_f / 10.0 }
puts "" 
# Получить новый массив, который бы содержал в себе те буквы английского алфавита, порядковый номер которых есть в нашем массиве
p abc = ('a'..'z').to_a.select {|i| arr.include?(('a'..'z').to_a.index(i))}
# Поменять местами минимальный и максимальный элементы массива
p arr[arr.index[arr.min], arr.index[arr.max] = arr.index[arr.max], arr.index[arr.min]]
puts ""
# найти элементы, которые находятся перед минимальным числом в массиве
p arr[0...arr.rindex(arr.min)]
puts ""
# необходимо найти три наименьших элемента.
p arr.sort.uniq[0..2]
